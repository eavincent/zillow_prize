---
title: "Zillow Project Analysis"
author: "Liz Vincent"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(corrplot)
library(dplyr)
library(ggplot2)
library(magrittr)
library(stringi)
library(stringr)
library(rebus)
library(gridExtra)
library(reshape2)
library(ggmap)
library(tidyr)

properties<-read.csv("properties_2016.csv",stringsAsFactors = F)  # This takes a while...~3 million rows, 58 columns
train<-read.csv("train_2016_v2.csv")
```

# Training Data

## Tidying

Tidy the training data by merging with the metadata and coercing numeric ID variables to factors.

```{r train_variable_class, echo=F}
train<-merge(train,properties,by="parcelid")
factor_vars <- str_subset(names(train),pattern="id")
factor_vars <- c(factor_vars,"fips","propertycountylandusecode","propertyzoningdesc","rawcensustractandblock","censustractandblock")
train[,factor_vars]<-lapply(train[,factor_vars],factor)
str(train)
```

### Missingness and Imputation

Calculate the missingness for each variable by counting the NA or empty string observations. Impute values based on other correlating variables.

```{r train_missingness, include=FALSE}
# Count the number of NAs or empty strings in each column of properties_2016
missingness<-lapply(train,function(x){
    ifelse(is.character(x),
          sum(str_detect(x,pattern=START %R% END)),
          sum(is.na(x))
  )
})

# Format missingness
missingness<-round(unlist(missingness)/nrow(train)*100,2)
missingness<-sort(missingness,decreasing=T)
missingness<-as.data.frame(missingness)
missingness$var<-stri_trans_totitle(row.names(missingness))
row.names(missingness)<-seq(1:nrow(missingness))
missingness<-select(missingness,c("var","missingness"))
missingness<-missingness %>% mutate(category = lapply(missingness,function(x){if(x < 5){"<5%"} else if(x>=5 & x <= 95){">=5%, <=95%"} else{">95%"}}))
missingness$category<-as.character(missingness$category)

p1 <- ggplot(missingness,aes(x=reorder(var, missingness),y=missingness,fill=category)) +
  geom_col() +
  scale_fill_manual(breaks=c(">95%",">=5%, <=95%","<5%"),values=c("blue","black","red")) +
  scale_y_continuous(limits = c(NA,100),expand = c(0,0)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),legend.position = c(0.87,0.1),axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.ticks.x=element_blank()) +
  guides(fill=guide_legend(element_blank())) +
  labs(y="Missingness (%)",x=element_blank()) +
  coord_flip()

p1

# Check if missingness is associated with logerror
character_variables<-names(which(sapply(train, class) == "character")) # Get names of all columns whose entries are characters

tmp1<-as.data.frame(is.na(train[,!(names(train) %in% character_variables)])) # Check if NA for all columns whose entries are not characters
tmp2<-as.data.frame(lapply(train[,names(train) %in% character_variables],function(x){ 
  str_detect(x,pattern = START %R% END)
}))  # Check if empty string for all columns whose entries are characters
df_missing<-cbind(tmp1,tmp2)
names(df_missing)<-names(select(df_missing,names(train))) # reorder to same order as train
df_missing<-sapply(df_missing,as.numeric)
cor_missing<-cor(df_missing)
cor_missing<-cor_missing[which(lapply(as.data.frame(df_missing),sum) > 1),which(lapply(as.data.frame(df_missing),sum) > 1)]

corrplot(cor_missing,type="lower", title="Correlation of the Missingness of Variables",order="hclust") 

cor_logerror_missing<-cor(df_missing,train$logerror)
cor_logerror_missing<-cor_logerror_missing[!is.na(cor_logerror_missing),]
cor_logerror_missing<-as.data.frame(cor_logerror_missing)
cor_logerror_missing$type<-row.names(cor_logerror_missing)

ggplot(cor_logerror_missing,aes(x=reorder(type, abs(cor_logerror_missing)), y=abs(cor_logerror_missing),fill=ifelse(cor_logerror_missing < 0, "Negative","Positive"))) +
  geom_col() +
  scale_fill_brewer(palette = "Set1") +
  coord_flip() +
  guides(fill=guide_legend("Direction of\nCorrelation")) +
  labs(y= "Absolute Value of Correlation with Log Error", x="")
```

```{r distance_matrix, include=F}
imputed_train<-train

p<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidcounty)) +
  geom_point() +
  theme(legend.position = "none")

q1<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidcity)) +
  geom_point() +
  theme(legend.position = "none")

r1<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidzip)) +
  geom_point() +
  theme(legend.position = "none")

s1<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidneighborhood)) +
  geom_point() +
  theme(legend.position = "none")

# Impute city based on zip and vice versa
# Will only work for cities and zips that are uniquely paired

# There are no entries that contain a neighborhood but /not/ a city or zip
# All entries have county id

region_table<-table(imputed_train$regionidcity,imputed_train$regionidzip)
melted_region_table<-melt(region_table)
names(melted_region_table)<-c("regionidcity","regionidzip","frequency")
melted_region_table<-melted_region_table[!(melted_region_table$frequency == 0),]
unique_cities<-names(which(table(melted_region_table$regionidcity) == 1)) # Cities that are uniquely associated with 1 zip code
city_key<-melted_region_table[melted_region_table$regionidcity %in% unique_cities,1:2] # Create a key to associate city with Zip
unique_zips<-names(which(table(melted_region_table$regionidzip) == 1)) # Zip codes that are uniquely associated with 1 city
zip_key<-melted_region_table[melted_region_table$regionidzip %in% unique_zips,1:2] # Create a key to associate Zip with city

# Check if there are entries that have zip but no city, and their zip is uniquely associated with one city
dim(imputed_train[is.na(imputed_train$regionidcity) & imputed_train$regionidzip %in% unique_zips,]) # 779 entries have a zip code uniquely associated with 1 city, but no city data
m<-match(imputed_train[is.na(imputed_train$regionidcity) & imputed_train$regionidzip %in% unique_zips,"regionidzip"],zip_key$regionidzip)
imputed_train[is.na(imputed_train$regionidcity) & imputed_train$regionidzip %in% unique_zips,"regionidcity"] <- zip_key$regionidcity[m]

# Check if there are entries that have city but no zip, and their city is uniquely associated with one zip
dim(imputed_train[is.na(imputed_train$regionidzip) & imputed_train$regionidcity %in% unique_cities,]) # 5 entries have a zip code uniquely associated with 1 city, but no city data
m<-match(imputed_train[is.na(imputed_train$regionidzip) & imputed_train$regionidcity %in% unique_cities,"regionidcity"],city_key$regionidcity)
imputed_train[is.na(imputed_train$regionidzip) & imputed_train$regionidcity %in% unique_cities,"regionidzip"] <- city_key$regionidzip[m]


# Use combination of city and zip to impute neighborhood
neighborhoods<-unique(imputed_train[,c("regionidcity","regionidzip","regionidneighborhood")])
neighborhoods<-neighborhoods[!(is.na(neighborhoods$regionidcity) | is.na(neighborhoods$regionidzip) | is.na(neighborhoods$regionidneighborhood)),]
neighborhoods<-unite(neighborhoods,col="city_zip",regionidcity,regionidzip,sep=".")
neighborhoods$city_zip<-factor(neighborhoods$city_zip)

m<-match(
  as.factor((imputed_train %>%
    filter(!is.na(regionidcity), !is.na(regionidzip), is.na(regionidneighborhood)) %>%
    unite("city_zip",regionidcity,regionidzip,sep=".") %>%
    filter(city_zip %in% neighborhoods$city_zip) %>%
    as.data.frame())$city_zip),
  neighborhoods$city_zip
)

imputed_train[!(is.na(imputed_train$regionidcity) | is.na(imputed_train$regionidzip)) & is.na(imputed_train$regionidneighborhood) & (unite(imputed_train,"city_zip",regionidcity,regionidzip,sep="."))$city_zip %in% neighborhoods$city_zip ,"regionidneighborhood"] <- neighborhoods$regionidneighborhood[m]

#city, zip, and neighborhood have been imputed as much as they can be with the information known about city and zip.

q2<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidcity)) +
  geom_point() +
  theme(legend.position = "none")

r2<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidzip)) +
  geom_point() +
  theme(legend.position = "none")

s2<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidneighborhood)) +
  geom_point() +
  theme(legend.position = "none")

grid.arrange(q1,r1,s1,q2,r2,s2,ncol=3)

#Create distance matrix using latitude and longitude coordinates so that regional values may be imputed based on k nearest neighbors

coordinates<-train[,c("longitude","latitude")]

coordinates$latitude<-as.numeric(str_replace(coordinates$latitude, pattern=capture(dgt(2)) %R% capture(one_or_more(DGT)),replacement=REF1 %R% DOT %R% REF2))
coordinates$longitude<-as.numeric(str_replace(coordinates$longitude, pattern=capture("-" %R% dgt(3)) %R% capture(one_or_more(DGT)),replacement=REF1 %R% DOT %R% REF2))

zip_na<-which(is.na(imputed_train$regionidzip))

samples<-sample(which(((imputed_train$longitude > -118000000 & imputed_train$latitude<33900000) | (imputed_train$longitude < -118750000 & imputed_train$latitude >34100000)) & !is.na(imputed_train$regionidzip)),10000)

distance_mat<-matrix(NA, nrow=length(zip_na),ncol=length(samples))

ggplot(imputed_train[c(samples,zip_na),], aes(x=latitude,y=longitude,color=regionidzip)) +
  geom_point() +
  theme(legend.position = "none")

ggplot(imputed_train[zip_na,], aes(x=latitude,y=longitude)) +
  geom_point() +
  theme(legend.position = "none")

ggplot(imputed_train[which((imputed_train$longitude > -118000000 & imputed_train$latitude<33900000) | (imputed_train$longitude < -118750000 & imputed_train$latitude >34100000)),], aes(x=latitude,y=longitude, color=regionidzip)) +
  geom_point() +
  theme(legend.position = "none")

for (i in 1:length(zip_na)){
  for (j in 1:length(samples)){
    distance_mat[i,j]<-
      sqrt((coordinates[zip_na[i],"latitude"] - coordinates[samples[j],"latitude"]) ** 2 + (coordinates[zip_na[i],"longitude"] - coordinates[samples[j],"longitude"]) ** 2)
 }
}

distance_mat<-as.data.frame(distance_mat)
names(distance_mat)<-samples

for(i in 1:length(zip_na)){
imputed_train[zip_na[i],"regionidzip"]<-factor(names(which.max(table(as.character(imputed_train[names(sort(distance_mat[i,])[1:10]),"regionidzip"])))))
}
# All zips are imputed

# Impute 23 more city IDs by matching with unique zips
m<-match(imputed_train[is.na(imputed_train$regionidcity) & imputed_train$regionidzip %in% unique_zips,"regionidzip"],zip_key$regionidzip)
imputed_train[is.na(imputed_train$regionidcity) & imputed_train$regionidzip %in% unique_zips,"regionidcity"] <- zip_key$regionidcity[m]

# Impute the remaining 1004 missing city data by coordinates
city_na<-which(is.na(imputed_train$regionidcity))

samples<-sample(which(!is.na(imputed_train$regionidcity)),10000)
distance_mat<-matrix(NA, nrow=length(city_na),ncol=length(samples))

for (i in 1:length(city_na)){
  for (j in 1:length(samples)){
    distance_mat[i,j]<-
      sqrt((coordinates[city_na[i],"latitude"] - coordinates[samples[j],"latitude"]) ** 2 + (coordinates[city_na[i],"longitude"] - coordinates[samples[j],"longitude"]) ** 2)
 }
}

distance_mat<-as.data.frame(distance_mat)
names(distance_mat)<-samples

for(i in 1:length(city_na)){
  imputed_train[city_na[i],"regionidcity"]<-factor(names(which.max(table(as.character(imputed_train[names(sort(distance_mat[i,])[1:10]),"regionidcity"])))))
}
# All cities are imputed

m<-match(
  as.factor((imputed_train %>%
    filter(!is.na(regionidcity), !is.na(regionidzip), is.na(regionidneighborhood)) %>%
    unite("city_zip",regionidcity,regionidzip,sep=".") %>%
    filter(city_zip %in% neighborhoods$city_zip) %>%
    as.data.frame())$city_zip),
  neighborhoods$city_zip
)

imputed_train[!(is.na(imputed_train$regionidcity) | is.na(imputed_train$regionidzip)) & is.na(imputed_train$regionidneighborhood) & (unite(imputed_train,"city_zip",regionidcity,regionidzip,sep="."))$city_zip %in% neighborhoods$city_zip ,"regionidneighborhood"] <- neighborhoods$regionidneighborhood[m]


q3<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidcity)) +
  geom_point() +
  theme(legend.position = "none")

r3<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidzip)) +
  geom_point() +
  theme(legend.position = "none")

s3<-ggplot(imputed_train, aes(x=latitude,y=longitude,color=regionidneighborhood)) +
  geom_point() +
  theme(legend.position = "none")

grid.arrange(q1,r1,s1,q2,r2,s2,q3,r3,s3,ncol=3)
```

```{r train_imputation}
imputed_train$taxdelinquencyflag <- ifelse(imputed_train$taxdelinquencyflag == "Y",TRUE,FALSE)
imputed_train[!is.na(imputed_train$taxdelinquencyyear) & imputed_train$taxdelinquencyyear == 0,"taxdelinquencyyear"] <- NA

imputed_train[!is.na(imputed_train$fireplacecnt),"fireplaceflag"]<-TRUE
imputed_train[imputed_train$fireplaceflag == "true","fireplaceflag"] <- TRUE
imputed_train$fireplaceflag <- as.logical(imputed_train$fireplaceflag)

imputed_train[!is.na(imputed_train$basementsqft),"basement"] <- TRUE
imputed_train<-imputed_train[,!(names(imputed_train) == "storytypeid")] # Only storytypeid is "basement" and completely overlaps with basementsqft values - created new value called "basement" that is logical and removing storytypeid

imputed_train[!is.na(imputed_train$poolcnt) | !is.na(imputed_train$poolsizesum) | !is.na(imputed_train$pooltypeid10) | !is.na(imputed_train$pooltypeid2) | !is.na(imputed_train$pooltypeid7),"pool"] <- TRUE
imputed_train$pooltypeid10<-as.logical(ifelse(imputed_train$pooltypeid10 == 1, TRUE, NA))
imputed_train$pooltypeid7<-as.logical(ifelse(imputed_train$pooltypeid7 == 1, TRUE, NA))
imputed_train$pooltypeid2<-as.logical(ifelse(imputed_train$pooltypeid2 == 1, TRUE, NA))

imputed_train[!is.na(imputed_train$pooltypeid10) | !is.na(imputed_train$pooltypeid7),"pooltypeid2"] <- FALSE
imputed_train[!is.na(imputed_train$pooltypeid10) | !is.na(imputed_train$pooltypeid2),"pooltypeid7"] <- FALSE
imputed_train[!is.na(imputed_train$pooltypeid7) | !is.na(imputed_train$pooltypeid2),"pooltypeid10"] <- FALSE

imputed_train<-imputed_train[,!(names(imputed_train) %in% c("poolcnt","hashottuborspa"))] # These are redundant with "pool" and "poolytpeid2/10", which both include information about hottub or spa

# Impute unit count based on propertly land use type ID
imputed_train[imputed_train$propertylandusetypeid == 246 & is.na(imputed_train$unitcnt),"unitcnt"]<-2
imputed_train[imputed_train$propertylandusetypeid == 247 & is.na(imputed_train$unitcnt),"unitcnt"]<-3
imputed_train[imputed_train$propertylandusetypeid == 248 & is.na(imputed_train$unitcnt),"unitcnt"]<-4
```

```{r train_recalculate_missingness,}
missingness<-lapply(imputed_train,function(x){
    ifelse(is.character(x),
          sum(str_detect(x,pattern=START %R% END)),
          sum(is.na(x))
  )
})

# Format missingness
missingness<-round(unlist(missingness)/nrow(train)*100,2)
missingness<-sort(missingness,decreasing=T)
missingness<-as.data.frame(missingness)
missingness$var<-stri_trans_totitle(row.names(missingness))
row.names(missingness)<-seq(1:nrow(missingness))
missingness<-select(missingness,c("var","missingness"))

missingness<-missingness %>% mutate(category = lapply(missingness,function(x){if(x < 5){"<5%"} else if(x>=5 & x <= 95){">=5%, <=95%"} else{">95%"}}))
missingness$category<-as.character(missingness$category)
```

```{r echo=F}
p2 <- ggplot(missingness,aes(x=reorder(var, missingness),y=missingness,fill=category)) +
  geom_col() +
  scale_fill_manual(breaks=c(">95%",">=5%, <=95%","<5%"),values=c("blue","black","red")) +
  scale_y_continuous(limits = c(NA,100),expand = c(0,0)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),legend.position = c(0.87,0.1),axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.ticks.x=element_blank()) +
  guides(fill=guide_legend(element_blank())) +
  labs(y="Missingness (%)",x=element_blank()) +
  coord_flip()

p2

```

### Correlation

```{r pressure, echo=FALSE}
# calculate correlations of variables
numeric_vars<-names(which(lapply(imputed_train,is.numeric) == TRUE))
numeric_vars<-numeric_vars[!(numeric_vars %in% c("basementsqft","finishedsquarefeet13","assessmentyear","finishedsquarefeet15","finishedsquarefeet6","threequarterbathnbr","unitcnt"))]
M <- cor(imputed_train[,names(imputed_train) %in% numeric_vars],use="pairwise.complete.obs")
corrplot(M,type="lower",order="hclust")
# None of the numberic variables are correlated with logerror
```

### Models

#### Predict the Mean
```{r}
train$pred_logerror_mean<-mean(train$logerror)
ggplot(train,aes(x=logerror,y=pred_logerror_mean)) + 
  geom_point() +
  geom_abline(slope=1) +
  ylim(c(-5,5))

pred_by_mean_RMSE<-sqrt(mean((train$pred_logerror_mean - train$logerror) ** 2))
  
rss<-sum((train$pred_logerror_mean - train$logerror) ** 2)
ss<-sum((train$logerror - mean(train$logerror)) ** 2)

pred_by_mean_rsquare<-1-rss/ss
```
